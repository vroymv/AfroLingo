// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ThemePreference {
  SYSTEM
  LIGHT
  DARK
}

enum CommunityUserType {
  LEARNER
  NATIVE
  TUTOR
}

enum GroupPrivacy {
  PUBLIC
  PRIVATE
  INVITE
}

enum GroupRole {
  OWNER
  MEMBER
}

enum GroupInviteStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELED
}

enum NotificationType {
  GROUP_MESSAGE
  GROUP_INVITE
}

model Tutor {
  id         String @id @default(uuid())
  externalId String @unique // Stable ID for seeding/syncing (maps to Client MOCK_TUTORS[].id)

  // Linked app user identity (tutors are real users)
  userId String? @unique
  user   User?   @relation("TutorUser", fields: [userId], references: [id], onDelete: Cascade)

  name     String
  language String

  rating      Float
  reviewCount Int
  hourlyRate  Int

  specialties String[] @default([])
  bio         String   @db.Text
  avatar      String
  availability String
  lessonsCompleted Int

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([language])
  @@index([isActive])
  @@index([userId])
  @@map("tutors")
}

model TutorChatThread {
  id String @id @default(uuid())

  learnerId String
  tutorId   String

  // Read tracking (for unread counts)
  learnerLastReadAt DateTime?
  tutorLastReadAt   DateTime?

  // Inbox ordering / previews
  lastMessageAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  learner User @relation("TutorChatLearner", fields: [learnerId], references: [id], onDelete: Cascade)
  tutor   User @relation("TutorChatTutor", fields: [tutorId], references: [id], onDelete: Cascade)

  messages TutorChatMessage[]

  @@unique([learnerId, tutorId])
  @@index([learnerId, lastMessageAt(sort: Desc)])
  @@index([tutorId, lastMessageAt(sort: Desc)])
  @@map("tutor_chat_threads")
}

model TutorChatMessage {
  id String @id @default(uuid())

  threadId String
  senderId String

  body            String @db.Text
  clientMessageId String

  createdAt DateTime @default(now())

  thread TutorChatThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  sender User           @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@unique([senderId, clientMessageId])
  @@index([threadId, createdAt(sort: Desc)])
  @@index([senderId])
  @@map("tutor_chat_messages")
}

// User model
model User {
  id    String @id @default(uuid())
  email String @unique
  name  String

  // Tutor listing (optional; present when this user is a tutor)
  tutorListing Tutor? @relation("TutorUser")

  // Community profile (used by Community/People UI)
  userType     CommunityUserType @default(LEARNER)
  languages    String[]          @default([])
  bio          String?           @db.Text
  countryCode  String?           @db.VarChar(2)

  // Profile image
  profileImageUrl       String? // URL to user's profile image
  // Onboarding selections
  selectedLanguage      String? // e.g., "sw", "zu", "ln", "xh"
  selectedLevel         String? // e.g., "absolute-beginner", "beginner", "refresher"
  placementTestScore    Int?
  learningReasons       String[]  @default([]) // Array of reasons why they're learning
  timeCommitment        String? // e.g., "5min", "15min", "30min"
  onboardingCompleted   Boolean   @default(false)
  onboardingCompletedAt DateTime?
  currentOnboardingStep String? // Tracks the last onboarding step completed

  // App preferences
  themePreference         ThemePreference @default(DARK)
  soundEffectsEnabled     Boolean         @default(true)
  hapticsEnabled          Boolean         @default(true)
  offlineDownloadsEnabled Boolean         @default(false)

  // Notification preferences
  dailyReminderEnabled                    Boolean @default(true)
  dailyReminderTime                       String  @default("09:00") // local time, HH:mm
  streakAlertsEnabled                     Boolean @default(true)
  weeklySummaryEnabled                    Boolean @default(false)
  achievementUnlockedNotificationsEnabled Boolean @default(true)
  communityActivityNotificationsEnabled   Boolean @default(false)

  // Daily goal configuration & streaks
  dailyXpGoal       Int       @default(30) // Target XP per day
  dailyLessonGoal   Int? // Optional: target lessons per day
  timezone          String? // IANA timezone, e.g. "Africa/Nairobi"
  currentStreakDays Int       @default(0)
  longestStreakDays Int       @default(0)
  lastStreakDate    DateTime? @db.Date

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  progress         UserProgress[]
  activityProgress ActivityProgress[]
  practiceProgress PracticeActivityProgress[]
  dailyActivity    UserDailyActivity[]
  mistakes         UserMistake[]
  xpTransactions   XpTransaction[]
  storyProgress    UserStoryProgress[]

  // Community relationships
  following UserFollow[] @relation("UserFollows")
  followers UserFollow[] @relation("UserFollowedBy")

  // Tutor chat
  tutorChatsAsLearner TutorChatThread[] @relation("TutorChatLearner")
  tutorChatsAsTutor   TutorChatThread[] @relation("TutorChatTutor")
  tutorChatMessages   TutorChatMessage[]

  // Groups
  groupsCreated     Group[]           @relation("GroupsCreated")
  groupMemberships  GroupMembership[]
  groupMessages     GroupMessage[]
  groupInvitesReceived GroupInvite[] @relation("GroupInviteInvitedUser")
  groupInvitesSent     GroupInvite[] @relation("GroupInviteInvitedByUser")
  notifications     Notification[]

  @@map("users")
  @@index([userType])
  @@index([countryCode])
}

model UserFollow {
  id          String   @id @default(uuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  follower  User @relation("UserFollows", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("UserFollowedBy", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("user_follows")
}

model Group {
  id         String  @id @default(uuid())
  externalId String? @unique

  name        String
  description String? @db.Text

  // Simple language targeting for discovery (e.g., "sw", "zu")
  language String?
  tags     String[] @default([])

  privacy  GroupPrivacy @default(PUBLIC)
  avatarUrl String?
  coverImageUrl String?

  createdByUserId String
  createdByUser   User @relation("GroupsCreated", fields: [createdByUserId], references: [id], onDelete: Cascade)

  isActive   Boolean   @default(true)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  memberships GroupMembership[]
  invites     GroupInvite[]
  channels    GroupChannel[]
  messages    GroupMessage[]

  @@index([language])
  @@index([privacy])
  @@index([isActive])
  @@map("groups")
}

model GroupMembership {
  id      String @id @default(uuid())
  groupId String
  userId  String

  role GroupRole @default(MEMBER)

  joinedAt DateTime @default(now())
  leftAt   DateTime?

  // Used for unread calculations (v1)
  lastReadAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([userId])
  @@index([groupId])
  @@index([role])
  @@map("group_memberships")
}

model GroupInvite {
  id String @id @default(uuid())

  groupId String
  invitedUserId String
  invitedByUserId String

  status GroupInviteStatus @default(PENDING)

  createdAt DateTime @default(now())
  respondedAt DateTime?
  canceledAt DateTime?

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  invitedUser User @relation("GroupInviteInvitedUser", fields: [invitedUserId], references: [id], onDelete: Cascade)
  invitedByUser User @relation("GroupInviteInvitedByUser", fields: [invitedByUserId], references: [id], onDelete: Cascade)

  @@unique([groupId, invitedUserId])
  @@index([invitedUserId, status])
  @@index([groupId, status])
  @@index([invitedByUserId])
  @@map("group_invites")
}

model GroupChannel {
  id      String @id @default(uuid())
  groupId String

  name      String
  isDefault Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  group    Group          @relation(fields: [groupId], references: [id], onDelete: Cascade)
  messages GroupMessage[]

  @@index([groupId])
  @@index([isDefault])
  @@map("group_channels")
}

model GroupMessage {
  id        String @id @default(uuid())
  groupId   String
  channelId String?
  senderId  String

  body     String @db.Text
  metadata Json?

  // Client-provided idempotency key (unique per sender)
  clientMessageId String

  createdAt DateTime @default(now())

  group   Group         @relation(fields: [groupId], references: [id], onDelete: Cascade)
  channel GroupChannel? @relation(fields: [channelId], references: [id], onDelete: SetNull)
  sender  User          @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@unique([senderId, clientMessageId])
  @@index([groupId, createdAt(sort: Desc)])
  @@index([channelId, createdAt(sort: Desc)])
  @@index([senderId])
  @@map("group_messages")
}

model Notification {
  id     String @id @default(uuid())
  userId String

  type NotificationType
  data Json

  createdAt DateTime @default(now())
  readAt    DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, readAt])
  @@map("notifications")
}

// Unit model - Represents a learning unit (e.g., "The Alphabet", "Numbers")
model Unit {
  id         String   @id @default(uuid())
  externalId String   @unique // e.g., "unit-1" from JSON
  title      String
  level      String // e.g., "absolute-beginner", "beginner"
  icon       String // Emoji icon
  color      String // Hex color code
  xpReward   Int // XP awarded for completing this unit
  order      Int      @default(0) // For ordering units
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  userProgress UserProgress[]
  activities   Activity[]
  mistakes     UserMistake[]

  @@index([externalId])
  @@index([order])
  @@map("units")
}

// Activity model - Represents an activity within a lesson
model Activity {
  id           String  @id @default(uuid())
  externalId   String  @unique // e.g., "activity-alphabet-1" from JSON
  unitId       String
  type         String // high-level category, e.g., "multiple-choice", "dictation"
  // Metadata-only: identifier for the client-side component to render this activity
  componentKey String  @default("generic-activity") // e.g., "learn/alphabet/AlphabetActivity" or "learn/mcq/MultipleChoice"
  // Reference to external content (JSON key, CMS ID, file path, etc.)
  contentRef   String? // e.g., "activity-alphabet-1" in JSON, or "s3://.../activity.json"
  order        Int     @default(0) // For ordering activities within a lesson
  isActive     Boolean @default(true)
  featuredForPractice Boolean @default(false) // Show in Practice tab

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  unit             Unit               @relation(fields: [unitId], references: [id], onDelete: Cascade)
  activityProgress ActivityProgress[]
  practiceProgress PracticeActivityProgress[]
  mistakes         UserMistake[]

  @@index([externalId])
  @@index([unitId])
  @@index([order])
  @@index([type])
  @@index([componentKey])
  @@map("activities")
}

// User progress for practice activities (Practice tab)
model PracticeActivityProgress {
  id         String @id @default(uuid())
  userId     String
  activityId String

  // Completion status
  isCompleted Boolean  @default(false)
  isCorrect   Boolean? // Optional for practice types that have a notion of correctness

  // Performance tracking
  attempts          Int  @default(0)
  bestScore         Int? // Optional numeric score (0-100 or any scale your client uses)
  lastScore         Int?
  totalTimeSpentSec Int  @default(0)

  // Optional payloads for flexible practice activities
  lastAnswer Json?
  metadata   Json?

  // Timestamps
  startedAt     DateTime? // First time they started this practice activity
  lastAttemptAt DateTime?
  completedAt   DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  activity Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)

  @@unique([userId, activityId])
  @@index([userId])
  @@index([activityId])
  @@index([isCompleted])
  @@index([completedAt])
  @@map("practice_activity_progress")
}

// Karaoke practice exercises (audio + timed lyrics)
model KaraokeExercise {
  id String @id @default(uuid())

  // Optional stable ID for syncing seeded content
  externalId String? @unique

  title    String
  subtitle String?
  language String? // e.g. "sw", "zu", etc.

  // Where the audio clip lives (CDN URL, S3 key, etc.)
  audioClipUrl String

  // Timed lyrics/words payload used by the client for highlighting.
  // Suggested shape mirrors Client/data/karaoke-demo.json (lines -> words with startMs/endMs).
  transcript Json?

  durationMs Int?

  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([language])
  @@index([isActive])
  @@map("karaoke_exercises")
}

// User progress for units
model UserProgress {
  id                  String    @id @default(uuid())
  userId              String
  unitId              String
  progress            Int       @default(0) // 0-100
  completedActivities Int       @default(0)
  startedAt           DateTime  @default(now())
  completedAt         DateTime?
  lastAccessedAt      DateTime  @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  unit Unit @relation(fields: [unitId], references: [id], onDelete: Cascade)

  @@unique([userId, unitId])
  @@index([userId])
  @@index([unitId])
  @@map("user_progress")
}

// Removed LessonProgress model

// User progress for individual activities
model ActivityProgress {
  id         String @id @default(uuid())
  userId     String
  activityId String

  // Completion status
  isCompleted Boolean  @default(false)
  isCorrect   Boolean? // For activities with right/wrong answers
  isSkipped   Boolean  @default(false) // Did user skip this activity

  // Answer tracking
  userAnswer    Json? // Store user's final answer(s)
  answerHistory Json[] @default([]) // Track all answer attempts
  hintsUsed     Int    @default(0) // Number of hints requested

  // Performance
  timeSpent    Int? // Time spent in seconds
  attempts     Int  @default(1) // Number of attempts for this activity
  mistakeCount Int  @default(0) // Number of wrong attempts before success

  // XP and rewards
  xpEarned     Int     @default(0) // XP earned from this activity
  perfectScore Boolean @default(false) // Completed on first try without hints

  // Timestamps
  startedAt   DateTime  @default(now())
  completedAt DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  activity Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)

  @@unique([userId, activityId])
  @@index([userId])
  @@index([activityId])
  @@index([isCompleted])
  @@index([completedAt])
  @@map("activity_progress")
}

// Removed LessonSession model

// Track daily user activity and streaks
model UserDailyActivity {
  id     String   @id @default(uuid())
  userId String
  date   DateTime @db.Date // Date of activity (without time)

  // Activity metrics
  unitsCompleted      Int       @default(0)
  activitiesCompleted Int       @default(0)
  // App usage (best-effort; app may terminate without sending a close event)
  firstAppOpenedAt    DateTime? // First time the app was opened on this date (server time)
  lastAppOpenedAt     DateTime? // Most recent app open on this date (server time)
  lastAppClosedAt     DateTime? // Most recent app close/background on this date (server time)
  appOpensCount       Int       @default(0)
  appClosesCount      Int       @default(0)
  xpEarned            Int       @default(0)

  // Daily goal snapshot
  goalXp      Int?
  goalLessons Int?
  metGoal     Boolean @default(false)

  // Streak calculation
  isStreakDay Boolean @default(false) // Did user meet minimum criteria for streak

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@index([userId])
  @@index([date])
  @@index([isStreakDay])
  @@map("user_daily_activity")
}

// Track mistakes and incorrect answers for learning insights
model UserMistake {
  id         String @id @default(uuid())
  userId     String
  activityId String
  unitId     String

  // Mistake details
  questionText  String  @db.Text
  userAnswer    Json // What they answered
  correctAnswer Json // What the correct answer was
  mistakeType   String? // e.g., "spelling", "grammar", "vocabulary", "pronunciation"

  // Learning value
  wasReviewed    Boolean   @default(false) // Has user seen this in review
  reviewCount    Int       @default(0) // How many times reviewed
  lastReviewedAt DateTime?
  isMastered     Boolean   @default(false) // User now gets this correct consistently

  createdAt DateTime @default(now())

  // Relations
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  activity Activity @relation(fields: [activityId], references: [id], onDelete: Cascade)
  unit     Unit     @relation(fields: [unitId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([activityId])
  @@index([unitId])
  @@index([wasReviewed])
  @@index([isMastered])
  @@index([createdAt])
  @@map("user_mistakes")
}

// XP Transaction model - Ledger for all XP changes
model XpTransaction {
  id             String   @id @default(uuid())
  userId         String   @map("user_id")
  amount         Int // can be positive or negative
  sourceType     String   @map("source_type") // e.g. 'lesson_complete', 'quiz_attempt', 'streak_bonus'
  sourceId       String   @map("source_id") // ID of the originating entity (lessonId, attemptId, date, etc.)
  idempotencyKey String   @map("idempotency_key") // prevents duplicate awards on retries
  metadata       Json? // optional context: lang, difficulty, time spent, etc.
  createdAt      DateTime @default(now()) @map("created_at") @db.Timestamptz

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("xp_transactions")
  @@index([userId])
}

// Grammar tip model - Rotating daily tips per language
model GrammarTip {
  id        String   @id @default(uuid())
  language  String // e.g. "sw", "zu", "ln", "xh", or "general"
  text      String   @db.Text
  sortOrder Int      @default(0)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([language, sortOrder], name: "language_sortOrder")
  @@index([language])
  @@index([isActive])
  @@map("grammar_tips")
}

enum StoryDifficulty {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

enum StoryType {
  DIALOGUE
  NARRATIVE
  CULTURAL
}

enum StoryCategory {
  GREETING
  DIALOGUE
  CULTURE
  EVERYDAY
}

model Story {
  id            String          @id @default(uuid())
  externalId    String          @unique
  title         String
  description   String
  cover         String
  difficulty    StoryDifficulty
  estimatedTime String
  type          StoryType
  category      StoryCategory
  totalWords    Int
  isActive      Boolean         @default(true)
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  segments  StorySegment[]
  questions StoryQuestion[]
  progress  UserStoryProgress[]

  @@index([category])
  @@index([difficulty])
  @@index([type])
  @@map("stories")
}

model StorySegment {
  id               String   @id @default(uuid())
  storyId          String
  externalId       String
  sortOrder        Int
  speaker          String?
  text             String   @db.Text
  translation      String   @db.Text
  audioUrl         String?
  highlightedWords String[] @default([])
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  story Story @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@unique([storyId, externalId], name: "story_segments_storyId_externalId")
  @@unique([storyId, sortOrder], name: "story_segments_storyId_sortOrder")
  @@index([storyId])
  @@map("story_segments")
}

model StoryQuestion {
  id            String   @id @default(uuid())
  storyId       String
  externalId    String
  sortOrder     Int
  question      String   @db.Text
  options       String[] @default([])
  correctAnswer Int
  explanation   String   @db.Text
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  story Story @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@unique([storyId, externalId], name: "story_questions_storyId_externalId")
  @@unique([storyId, sortOrder], name: "story_questions_storyId_sortOrder")
  @@index([storyId])
  @@map("story_questions")
}

model UserStoryProgress {
  id             String    @id @default(uuid())
  userId         String
  storyId        String
  completedWords String[]  @default([])
  isCompleted    Boolean   @default(false)
  completedAt    DateTime?
  lastAccessedAt DateTime  @default(now())
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  story Story @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@unique([userId, storyId])
  @@index([userId])
  @@index([storyId])
  @@index([isCompleted])
  @@map("user_story_progress")
}
